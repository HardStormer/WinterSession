[[_Интеллектуальные системы и технологии Задачи]]

В качестве примера экспертной системы рассмотрим программу классификации "Птица или зверь". Система попытается угадать некоторое живое существо. Для получения требующейся для определения информации система задает ряд вопросов. Ниже приводится типичный диалог:  

```
У него есть волосы? Да  
Оно ест мясо? Нет  
У него острые зубы? Нет  
Оно дает молоко? Да  
У него есть копыта? Да  
У него длинная шея? Да  
У него длинные ноги? Да  
У него есть темные пятна? Да  
Загаданное животное животное — жираф!  
```
  
Программа ведет четкий и разумный диалог, запрашивая у пользователя необходимую информацию, которой она еще не располагает.  
Структура программы проектируется с помощью введения группы правил высокого уровня. Каждое такое правило описывает одно животное, четко указывая, какая именно информация нужна системе, чтобы прийти к выводу, что именно данное конкретное животное является искомым ответом. Например:  
  
``` SWI-Prolog
животное("Жираф") :- это("травоядное"),
свойство("У него", "длинная шея"),
свойство("У него", "длинные ноги"),
свойство("У него есть", "темные пятна").
```
  
Сходные правила имеются для всех животных, которые предстоит классифицировать программе.  
  
Предикаты с правой стороны правил "животное" всегда специфицируются другими правилами, помимо тех случаев, когда предикат просто проверяет, находится ли определенная информация в базе данных. Информация, вводимая в базу данных, извлекается из ответов пользователя на задаваемые вопросы. Все ответы сохраняются, так как они могут потребоваться позднее.  
  
Правила, проверяющие, находится ли в базе данных определенная информация, состоят из двух частей. Первая часть обеспечивает просмотр базы данных, причем ответ может быть найден сразу. Во второй части находятся запрос пользователю и запись его ответа в базу данных.  
  
Свою работу программа начинает с использования главного правила, называемого "цель".  

``` SWI-Prolog
цель:- животное(Арг),!,
write("Загаданное животное "),writeln(Арг),очистить.
цель:- write("К сожалению, это животное мне не известно."), очистить.  
```

Далее система пытается по очереди установить истинность или ложность каждого из правил высокого уровня, т.е. найти кандидата, которого она сможет проверить на соответствие предикату "животное". Как и характерно для Пролога, установление статуса правила высокого уровня влечет за собой проверку всего дерева подчиненных фактов и свидетельств, которые должны быть истинными, чтобы подтвердить основное заключение. По мере продвижения вниз по дереву программа соответственно ситуации задает нужные вопросы в нужное время для получения недостающей информации, поэтому ее поведение кажется разумным. Если в результате работы в базе знаний не нашлось животного, удовлетворяющего требованиям, сработает второй вариант предиката "цель", который просто напечатает фразу "К сожалению, это животное мне не известно". В программе правила просто применяются одно за другим, начиная с вершины дерева. В процессе такого сканирования ответ, безусловно, будет найден, если только правило для идентификации задуманного животного существует.  
  
Если нужно провести новый выбор, то нужно сначала очистить базу данных от ответов на вопросы, заданных при ведении последнего диалога. Они продолжают находиться в базе данных и будут влиять на следующие результаты, если их не удалить или не перезапустить программу. Предикат "очистить" очищает базу знаний.  
  
Рассмотрим теперь правила высокого уровня, описывающие свидетельства в пользу конкретного животного.  
  
``` SWI-Prolog
животное("Гепард") :- это("млекопитающее"),
это("хищник"),
свойство("Оно", "красно-коричневого цвета"),
свойство("У него", "темная окраска").
```

``` SWI-Prolog
животное("Тигр") :- это("млекопитающее"),
это("хищник"),
свойство("Оно", "красно-коричневого цвета"),
свойство("У него есть", "черные полосы").
```

``` SWI-Prolog
животное("Жираф") :- это("травоядное"),
свойство("У него", "длинная шея"),
свойство("У него", "длинные ноги"),
свойство("У него есть", "темные пятна").
```

``` SWI-Prolog
животное("Зебра") :- это("травоядное"),
свойство("У него есть", "черные полосы").
```

``` SWI-Prolog
животное("Страус") :- это("птица"),
нет_свойства("Оно", "умеет летать"),
свойство("У него", "длинная шея"),
свойство("У него", "длинные ноги"),
свойство("Оно", "черно-белого цвета").
```

``` SWI-Prolog
животное("Пингвин") :- это("птица"),
нет_свойства("Оно", "умеет летать"),
свойство("Оно", "умеет плавать"),
свойство("Оно ", "черно-белого цвета").
```

``` SWI-Prolog
животное("Альбатрос") :- это("птица"),
свойство("Оно", "хорошо летает").
```

Все правила поддерживаются на следующем, более низком уровне некоторыми соподчиненными правилами классификации животных:  

``` SWI-Prolog
это("млекопитающее") :- свойство("У него есть", "волосы").
это("млекопитающее") :- свойство("Оно", "дает молоко").
это("птица") :- свойство("У него есть", "перья").
это("птица") :- свойство("Оно", "умеет летать"),свойство("Оно", "откладывает яйца ").
это("хищник") :- свойство("Оно", "ест мясо").
это("хищник") :- свойство("У него", "острые зубы"),свойство("У него есть", "когти"), свойство("У него есть", "зоркие глаза").
это("травоядное") :- это("млекопитающее"),свойство("У него есть", "копыта").
это("травоядное") :- это("млекопитающее"),свойство("Оно", "жует жвачку").
```

В данной версии большая часть работы совершается служебными правилами. Они используются для проверки конкретных атрибутов животных, которые могут быть обнаружены в процессе диалога и записаны в базу данных. Здесь задействован механизм вопросов-ответов, поэтому необходимо подробно рассмотреть эти правила. Ниже следует соответствующая часть программы.  
  
```SWI-Prolog
свойство(Арг, Арг2) :- верно(Арг, Арг2), !.  
```
  
Истинность факта можно установить сразу, если его подтверждение есть в базе данных.  
  
``` SWI-Prolog
свойство(Арг, Арг2) :- not(ложно(Арг, Арг2)), узнать(Арг, Арг2, Ответ), Ответ=да.  
```
  
Если в базе знаний нет подтверждения факта, то следует сначала проверить наличие в базе данных отрицания этого факта `not(ложно(Арг, Арг2))`. Если отрицания в базе также не обнаружится, следует истинность факта у пользователя `узнать(Арг, Арг2, Ответ)` и убедиться, что пользователь его подтвердил.  
  
``` SWI-Prolog
нет_свойства(Арг, Арг2) :- ложно(Арг, Арг2), !.  
```
  
Ложность факта можно установить сразу, если его отрицание есть в базе данных.  
  
``` SWI-Prolog
нет_свойства(Арг, Арг2) :- not(верно(Арг, Арг2)), узнать(Арг, Арг2, Ответ), Ответ=нет.  
```
  
Если в базе знаний нет отрицания факта, то следует сначала проверить наличие в базе данных подтверждения этого факта `not(верно(Арг, Арг2))`. Если подтверждения в базе также не обнаружится, следует истинность факта у пользователя `узнать(Арг, Арг2, Ответ)` и убедиться, что пользователь его отверг.  
  
```SWI-Prolog
узнать(Арг, Арг2, Ответ) :- write(Арг),write(" "), write(Арг2), read(Ответ), запомнить(Арг, Арг2, Ответ).  
  
запомнить(Арг, Арг2, да) :- assert(верно(Арг,Арг2)).

запомнить(Арг, Арг2, нет) :- assert(ложно(Арг,Арг2)).
```

Команда assert помещает нужный факт в базу данных. Однако предварительно надо сообщить системе, что мы будем в базу вносить изменения. Для этого в начало программы следует добавить следующую строку.

```SWI-Prolog
:- dynamic верно/2, ложно/2.
```

Теперь осталось написать `правило"очистить"`.

```SWI-Prolog
очистить:-
retract(верно(_,_)), fail. 
очистить:-
retract(ложно(_,_)), fail.
```

Как легко догадаться, команда retract удаляет факты из базы данных.
  
Задание  
  
1. Сформировать собственную базу правил (не менее 20 правил) в произвольной предметной области на основе собственных знаний или знаний эксперта.  
  
2. Написать программу на Прологе, реализующий вышеприведенный алгоритм.